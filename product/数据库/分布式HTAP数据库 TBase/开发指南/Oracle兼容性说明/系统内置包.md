## DBMS_RANDOM
DBMS_RANDOM 包用于产生随机值。DBMS_RANDOM中可以使用的存储过程及函数如下表所示：

| 存储过程/函数 | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| *INITIALIZE   | 用一个种子值来初始化DBMS_RANDOM                              |
| NORMAL        | 返回服从正态分布的一组数                                     |
| *RANDOM       | 返回值的范围为： [-2^31, 2^31)，返回的是整数                 |
| *SEED         | 功能和INITIALIZE函数类似，实际上，INITIALIZE函数被淘汰，推荐的替代函数即是SEED函数。与INITIALIZE函数不同的是SEED函数同时支持数值和字符作为种子值，而INITIALIZE函数只支持数值 |
| *STRING       | 随机生成字符串                                               |
| *TERMINATE    | 在使用完DBMS_RANDOM包后，用该函数进行终止                    |
| *VALUE        | 随机返回数值                                                 |

示例：
```
 Create table random_t1(col1 int,col2 numeric,col3 numeric,col4 numeric,col5  numeric);
    Create table random_t2 as select * from random_t1;
    begin
    perform dbms_random.initialize(100);
    for i in 1..100 loop
    insert into random_t1 values(i,dbms_random.normal(),dbms_random.random(),dbms_random.value(),dbms_random.value(10,20));
    end loop;
    end;
    /
    begin
    perform dbms_random.initialize(100);
    for i in 1..100 loop
    insert into random_t2 values(i,dbms_random.normal(),dbms_random.random(),dbms_random.value(),dbms_random.value(10,20));
    end loop;
    end;
    /
    select * from random_t1 minus select * from random_t2;
    Drop table if exists random_t1;
    Drop table if exists random_t2;
```
   
## DBMS_SQL
DBMS_SQL可以在应用的运行时间构建查询和其它的命令。DBMS_SQL中可以使用的存储过程及函数如下表所示：

| 存储过程/函数                                                | 描述                                         |
| ------------------------------------------------------------ | -------------------------------------------- |
| BIND_VARIABLE(c, name, value [, out_value_size ])            | Bind a value to a variable                   |
| BIND_VARIABLE_CHAR(c, name, value [, out_value_size ])       | Bind a CHAR value to a variable              |
| BIND_VARIABLE_RAW(c, name, value [, out_value_size ])        | Bind a RAW value to a variable               |
| CLOSE_CURSOR(c IN OUT)                                       | Close a cursor                               |
| COLUMN_VALUE(c, position, value OUT [, column_error OUT [, actual_length OUT ]]) | Return a column value into a variable.       |
| COLUMN_VALUE_CHAR(c, position, value OUT [, column_error OUT [, actual_length OUT ]]) | Return a CHAR column value into a variable.  |
| COLUMN_VALUE_RAW(c, position, value OUT [, column_error OUT [, actual_length OUT ]]) | Return a RAW column value into a variable.   |
| DEFINE_COLUMN(c, position, column [, column_size ])          | Define a column in the SELECT list.          |
| DEFINE_COLUMN_CHAR(c, position, column, column_size)         | Define a CHAR column in the SELECT list.     |
| DEFINE_COLUMN_RAW(c, position, column, column_size)          | Define a RAW column in the SELECT list.      |
| DESCRIBE_COLUMNS                                             | Defines columns to hold a cursor result set. |
| EXECUTE(c)                                                   | Execute a cursor.                            |
| EXECUTE_AND_FETCH(c [, exact ])                              | Execute a cursor and fetch a single row.     |
| FETCH_ROWS(c)                                                | Fetch rows from the cursor.                  |
| IS_OPEN(c)                                                   | Check if a cursor is open.                   |
| LAST_ROW_COUNT                                               | Return cumulative number of rows fetched.    |
| OPEN_CURSOR                                                  | Open a cursor.                               |
| PARSE(c, statement, language_flag)                           | Parse a statement.                           |

示例：
```
set client_min_messages TO error;
    CREATE EXTENSION IF NOT EXISTS dbms_sql;
    set client_min_messages TO default;
    
    do
    $$
    declare
    c  int;
    strval varchar;
    intval int;
    nrows  int default 30;
    begin
    c := dbms_sql.open_cursor();
    call dbms_sql.parse(c, 'select ''ahoj'' || i, i from generate_series(1, :nrows) g(i)');
    call dbms_sql.bind_variable(c, 'nrows', nrows);
    call dbms_sql.define_column(c, 1, strval);
    call dbms_sql.define_column(c, 2, intval);
    perform dbms_sql.execute(c);
    while dbms_sql.fetch_rows(c) > 0
    loop
    call dbms_sql.column_value(c, 1, strval);
    call dbms_sql.column_value(c, 2, intval);
    raise notice 'c1: %, c2: %', strval, intval;
    end loop;
    call dbms_sql.close_cursor(c);
    end;
    $$;
    
    do
    $$
    declare
    c  int;
    strval varchar;
    intval int;
    nrows  int default 30;
    begin
    c := dbms_sql.open_cursor();
    call dbms_sql.parse(c, 'select ''ahoj'' || i, i from generate_series(1, :nrows) g(i)');
    call dbms_sql.bind_variable(c, 'nrows', nrows);
    call dbms_sql.define_column(c, 1, strval);
    call dbms_sql.define_column(c, 2, intval);
    perform dbms_sql.execute(c);
    while dbms_sql.fetch_rows(c) > 0
    loop
    strval := dbms_sql.column_value_f(c, 1, strval);
    intval := dbms_sql.column_value_f(c, 2, intval);
    raise notice 'c1: %, c2: %', strval, intval;
    end loop;
    call dbms_sql.close_cursor(c);
    end;
    $$;
    
    create table foo
    (
    a int,
    b varchar,
    c numeric
    );
    
    do
    $$
    declare
    c int;
    begin
    c := dbms_sql.open_cursor();
    call dbms_sql.parse(c, 'insert into foo values(:a, :b, :c)');
    for i in 1..100
    loop
    call dbms_sql.bind_variable(c, 'a', i);
    call dbms_sql.bind_variable(c, 'b', 'Ahoj ' || i);
    call dbms_sql.bind_variable(c, 'c', i + 0.033);
    perform dbms_sql.execute(c);
    end loop;
    end;
    $$;
    
    select *
    from foo
    order by a;
    truncate foo;
    
    do
    $$
    declare
    c int;
    begin
    c := dbms_sql.open_cursor();
    call dbms_sql.parse(c, 'insert into foo values(:a, :b, :c)');
    for i in 1..100
    loop
    perform dbms_sql.bind_variable_f(c, 'a', i);
    perform dbms_sql.bind_variable_f(c, 'b', 'Ahoj ' || i);
    perform dbms_sql.bind_variable_f(c, 'c', i + 0.033);
    perform dbms_sql.execute(c);
    end loop;
    end;
    $$;
    
    select *
    from foo
    order by a;
    truncate foo;

    do
    $$
    declare
    c  int;
    a  int[];
    b  varchar[];
    ca numeric[];
    begin
    c := dbms_sql.open_cursor();
    call dbms_sql.parse(c, 'insert into foo values(:a, :b, :c)');
    a := ARRAY [1, 2, 3, 4, 5];
    b := ARRAY ['Ahoj', 'Nazdar', 'Bazar'];
    ca := ARRAY [3.14, 2.22, 3.8, 4];
    
    call dbms_sql.bind_array(c, 'a', a);
    call dbms_sql.bind_array(c, 'b', b);
    call dbms_sql.bind_array(c, 'c', ca);
    raise notice 'inserted rows %', dbms_sql.execute(c);
    end;
    $$;
    
    select *
    from foo
    order by a;
    truncate foo;
    
    do
    $$
    declare
    c  int;
    a  int[];
    b  varchar[];
    ca numeric[];
    begin
    c := dbms_sql.open_cursor();
    call dbms_sql.parse(c, 'insert into foo values(:a, :b, :c)');
    a := ARRAY [1, 2, 3, 4, 5];
    b := ARRAY ['Ahoj', 'Nazdar', 'Bazar'];
    ca := ARRAY [3.14, 2.22, 3.8, 4];
    
    call dbms_sql.bind_array(c, 'a', a, 2, 3);
    call dbms_sql.bind_array(c, 'b', b, 3, 4);
    call dbms_sql.bind_array(c, 'c', ca);
    raise notice 'inserted rows %', dbms_sql.execute(c);
    end;
    $$;
    
    select *
    from foo
    order by a;
    truncate foo;
    
    do
    $$
    declare
    c  int;
    a  int[];
    b  varchar[];
    ca numeric[];
    begin
    c := dbms_sql.open_cursor();
    call dbms_sql.parse(c, 'select i, ''Ahoj'' || i, i + 0.003 from generate_series(1, 35) g(i)');
    call dbms_sql.define_array(c, 1, a, 10, 1);
    call dbms_sql.define_array(c, 2, b, 10, 1);
    call dbms_sql.define_array(c, 3, ca, 10, 1);
    
    perform dbms_sql.execute(c);
    while dbms_sql.fetch_rows(c) > 0
    loop
    call dbms_sql.column_value(c, 1, a);
    call dbms_sql.column_value(c, 2, b);
    call dbms_sql.column_value(c, 3, ca);
    raise notice 'a = %', a;
    raise notice 'b = %', b;
    raise notice 'c = %', ca;
    end loop;
    call dbms_sql.close_cursor(c);
    end;
    $$;

```

    

## DBMS_STATS
DBMS_STATS能良好地估计统计数据(尤其是针对较大的分区表)，并能获得更好的统计结果,最终制定出速度更快的SQL执行计划。包含以下接口：

| 接口                  | 描述                                   |
| --------------------- | -------------------------------------- |
| GATHER_DATABASE_STATS | 分析数据库，包括所有用户对象和系统对象 |
| GATHER_TABLE_STATS    | 分析表                                 |
| GET_COLUMN_STATS      | 取得列的统计信息                       |
| GET_INDEX_STATS       | 取得索引的统计信息                     |
| GET_TABLE_STATS       | 取得表的统计信息                       |

示例：
```
 CREATE EXTENSION IF NOT EXISTS tbase_oracle_package_function;
    
    create user godlike_dbms_stats superuser;
    create user joe;
    create user no_privilege;
    
    \c postgres godlike_dbms_stats
    grant usage on schema dbms_stats to no_privilege;
    grant usage on schema dbms_stats to joe;
    
    \c postgres joe
    -- table joe_t
    create table joe_t (id integer not null PRIMARY KEY, test integer);
    create index joe_t_test_idx on joe_t(test);
    insert into joe_t SELECT generate_series(1,1000) as key, (random()*(10^3))::integer;
    
    \c postgres joe
    exec dbms_stats.gather_table_stats(ownname => 'joe',tabname => 'joe_t');
    exec dbms_stats.get_table_stats(ownname => 'joe',tabname => 'joe_t');
    exec dbms_stats.get_column_stats('joe', 'joe_t', 'test');
    exec dbms_stats.get_index_stats('joe', 'joe_t_test_idx');
    
    -- table joe_t_p
    create table joe_t_p (id integer not null PRIMARY KEY, test integer) partition by range (id) begin (1) step (5) partitions (200) distribute by shard(id);
    create index joe_t_p_test_idx on joe_t_p(test);
    insert into joe_t_p SELECT generate_series(1,1000) as key, (random()*(10^3))::integer;
    
    exec dbms_stats.gather_database_stats();
    exec dbms_stats.get_table_stats(ownname => 'joe',tabname => 'joe_t_p');
    exec dbms_stats.get_column_stats('joe', 'joe_t_p', 'test');
    exec dbms_stats.get_index_stats('joe', 'joe_t_p_test_idx');
    exec dbms_stats.get_table_stats('joe', 'joe_t_p', 'joe_t_p_part_0');
    exec dbms_stats.get_index_stats('joe', 'joe_t_p_test_idx', 'joe_t_p_test_idx_part_0');
    
    -- clean
    \c postgres godlike_dbms_stats
    drop table joe_t;
    drop table joe_t_p;
    REVOKE usage ON schema dbms_stats FROM joe;
    REVOKE usage ON schema dbms_stats FROM no_privilege;
    drop user joe;
    drop user no_privilege;
```

## DBMS_LOB
DBMS_LOB用于在大对象上进行操作。DBMS_LOB包提供了子程序可以在BLOB、CLOB、NCLOB、BFILE和临时LOB上操作的子程序。使用DBMS_LOB可以访问和处理LOB的特定部分或全部

| 存储过程/函数                                                | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| APPEND(dest_lob IN OUT,src_lob)                              | Appends one large object to another.                         |
| COMPARE(lob_1, lob_2 [, amount[, offset_1 [, offset_2 ]]])   | Compares two large objects.                                  |
| CONVERTOBLOB(dest_lob IN OUT,src_clob, amount, dest_offsetIN OUT, src_offset IN OUT,blob_csid, lang_context IN OUT,warning OUT) | Converts character data to binary.                           |
| CONVERTTOCLOB(dest_lob IN OUT,src_blob, amount, dest_offsetIN OUT, src_offset IN OUT,blob_csid, lang_context IN OUT,warning OUT) | Converts binary data to character.                           |
| COPY(dest_lob IN OUT, src_lob,amount [, dest_offset [,src_offset ]]) | Copies one large object to another.                          |
| ERASE(lob_loc IN OUT, amount IN OUT [, offset ])             | Erase a large object.                                        |
| GET_STORAGE_LIMIT(lob_loc)                                   | Get the storage limit for large objects.                     |
| GETLENGTH(lob_loc)                                           | Get the length of the large object.                          |
| INSTR(lob_loc, pattern [,offset [, nth ]])                   | Get the position of the nth occurrence of a pattern in the large object starting atoffset. |
| READ(lob_loc, amount IN OUT,offset, buffer OUT)              | Read a large object.                                         |
| SUBSTR(lob_loc [, amount [,offset ]])                        | Get part of a large object.                                  |
| TRIM(lob_loc IN OUT, newlen)                                 | Trim a large object to the specified length.                 |
| WRITE(lob_loc IN OUT, amount,offset, buffer)                 | Write data to a large object.                                |
| WRITEAPPEND(lob_loc IN OUT,amount, buffer)                   | Write data from the buffer to the end of a large object.     |

示例：
```
    DBMS_LOB.WRITEAPPEND (
    lob_loc IN OUT NOCOPY BLOB, 
    amount  ININTEGER, 
    buffer  INRAW); 
    
    DBMS_LOB.WRITEAPPEND (
    lob_loc IN OUT NOCOPY CLOB CHARACTER SET ANY_CS, 
    amount  ININTEGER, 
    buffer  INVARCHAR2 CHARACTER SET lob_loc%CHARSET);

    declare
    v_clob1 clob;
    begin
    v_clob1:=to_clob('123456');
    dbms_output.put_line(v_clob1);
    DBMS_LOB.WRITEAPPEND(v_clob1,3,'789');
    dbms_output.put_line(v_clob1);
    end;
    /
```

## DBMS_JOB
DBMS_JOB主要用来对在JOB QUEUE中的JOB做管理。该包已经被DBMS_SCHEDULER 包所取代. 特别是,如果你正在管理JOB以控制系统负载，那么你应该考虑通过收回用户在该 包上的执行权限，以禁和DBMS_JOB包。
示例：
```
declare
      jobno number;
      begin dbms_job.submit(
    job=>jobno, 
      what=>'proc_job(2);',
      next_date=>sysdate,
      interval=>'sysdate+1/1440'); 
      COMMIT;
      dbms_output.put_line(jobno);
       end;
       /
```
     
## DBMS_ASSERT
这个包来判定输入值的属性。
示例：
```
select dbms_assert.enquote_name('TBase') from dual;
```
    
## DBMS_OUTPUT
DBMS_OUTPUT用于向消息缓冲区发送消息（文本行的形式出现），或者从消息缓冲区中获取消息。

| 存储过程/函数                         | 描述                                                         |
| ------------------------------------- | ------------------------------------------------------------ |
| DISABLE                               | Disable the capability to send and receive messages.         |
| ENABLE(buffer size)                   | Enable the capability to send and receive messages.          |
| GET LINE(line OUT, status OUT)        | Get a line from the message buffer.                          |
| GET LINES(lines OUT, numlines IN OUT) | Get multiple lines from the message buffer.                  |
| NEW LINE                              | Puts an end-of-line character sequence.                      |
| PUT(item)                             | Puts a partial line without an end-of-line character sequence. |
| PUT LINE(item)                        | Puts a complete line with an end-of-line character sequence. |
| SERVEROUTPUT(stdout)                  | Direct messages from PUT, PUT LINE, or NEW_LINE to either standard output or the message buffer. |

示例：
```
 \set ECHO none
    SET client_min_messages = warning;
    SET DATESTYLE TO ISO;
    SET client_encoding = utf8;
    \pset null '<NULL>'
    \set ECHO all
    
    DROP FUNCTION dbms_output_test();
    DROP TABLE dbms_output_test;
    
    -- DBMS_OUTPUT.DISABLE [0]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER;
    BEGIN
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.PUT_LINE [1]
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff1	VARCHAR(20) := 'orafce';
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('t');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE');
    	PERFORM DBMS_OUTPUT.PUT_LINE (buff1);
    	PERFORM DBMS_OUTPUT.PUT ('ABC');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('');
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.PUT_LINE [2]
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('t');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORA
    F
    CE');
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.PUT [1]
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff1	VARCHAR(20) := 'ora';
    	buff2	VARCHAR(20) := 'f';
    	buff3	VARCHAR(20) := 'ce';
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('t');
    	PERFORM DBMS_OUTPUT.PUT ('ORA');
    	PERFORM DBMS_OUTPUT.PUT ('F');
    	PERFORM DBMS_OUTPUT.PUT ('CE');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('');
    	PERFORM DBMS_OUTPUT.PUT ('ABC');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('');
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.PUT [2]
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('t');
    	PERFORM DBMS_OUTPUT.PUT ('ORA
    F
    CE');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('');
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.GET_LINE [1]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 2');
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    SELECT * FROM dbms_output_test order by buff;
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.GET_LINE [2]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 2');
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 3');
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.GET_LINE [3]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 2');
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.PUT ('ORA');
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.GET_LINE [4]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 2');
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.NEW_LINE();
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.GET_LINE [5]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1
    ');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 2');
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.GET_LINE [6]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORA
    F
    CE');
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.GET_LINES [1]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	buff1	VARCHAR(20);
    	buff2	VARCHAR(20);
    	buff3	VARCHAR(20);
    	stts	INTEGER := 10;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 2');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 3');
    	SELECT INTO buff1,buff2,buff3,stts lines[1],lines[2],lines[3],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff1, stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff2, stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff3, stts);
    	SELECT INTO buff,stts lines[1],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.GET_LINES [2]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	buff1	VARCHAR(20);
    	buff2	VARCHAR(20);
    	stts	INTEGER := 2;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 2');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 3');
    	SELECT INTO buff1,buff2,stts lines[1],lines[2],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff1, stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff2, stts);
    	SELECT INTO buff,stts lines[1],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.GET_LINES [3]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER := 1;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 2');
    	SELECT INTO buff,stts lines[1],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 3');
    	SELECT INTO buff,stts lines[1],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	SELECT INTO buff,stts lines[1],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.GET_LINES [4]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER := 1;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 2');
    	SELECT INTO buff,stts lines[1],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.PUT ('ORA');
    	SELECT INTO buff,stts lines[1],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	SELECT INTO buff,stts lines[1],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.GET_LINES [5]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER := 1;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 2');
    	SELECT INTO buff,stts lines[1],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.NEW_LINE();
    	SELECT INTO buff,stts lines[1],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	SELECT INTO buff,stts lines[1],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.GET_LINES [6]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER := 1;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORA
    F
    CE');
    	SELECT INTO buff,stts lines[1],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.NEW_LINE [1]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff1	VARCHAR(20);
    	buff2	VARCHAR(20);
    	stts	INTEGER := 10;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT ('ORA');
    	PERFORM DBMS_OUTPUT.NEW_LINE();
    	PERFORM DBMS_OUTPUT.PUT ('FCE');
    	PERFORM DBMS_OUTPUT.NEW_LINE();
    	SELECT INTO buff1,buff2,stts lines[1],lines[2],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff1, stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff2, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.NEW_LINE [2]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(3000), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff1	VARCHAR(3000);
    	stts	INTEGER := 10;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.ENABLE(2000);
    	FOR j IN 1..1999 LOOP
    		PERFORM DBMS_OUTPUT.PUT ('A');
    	END LOOP;
    	PERFORM DBMS_OUTPUT.NEW_LINE();
    	SELECT INTO buff1,stts lines[1],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff1, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.DISABLE [1]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 2');
    	PERFORM DBMS_OUTPUT.ENABLE();
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 3');
    	PERFORM DBMS_OUTPUT.DISABLE();
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.ENABLE();
    
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.PUT ('ORAFCE TEST 4');
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.NEW_LINE();
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.PUT ('ORAFCE TEST 5');
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.NEW_LINE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.DISABLE [2]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER := 10;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	SELECT INTO buff,stts lines[1],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.ENABLE [1]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	status	INTEGER;
    	num		INTEGER := 2000;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('t');
    	PERFORM DBMS_OUTPUT.ENABLE(2000);
    	PERFORM DBMS_OUTPUT.PUT ('ORAFCE TEST 1');
    	PERFORM DBMS_OUTPUT.NEW_LINE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.ENABLE [2]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.PUT ('ORAFCE TEST 2');
    	PERFORM DBMS_OUTPUT.NEW_LINE();
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.ENABLE [3]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER := 10;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	SELECT INTO buff,stts lines[1],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.ENABLE [4]
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('t');
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	FOR j IN 1..2000 LOOP
    		PERFORM DBMS_OUTPUT.PUT ('A');
    	END LOOP;
    	PERFORM DBMS_OUTPUT.NEW_LINE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.ENABLE [5]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE(NULL);
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.ENABLE [6]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	PERFORM DBMS_OUTPUT.ENABLE();
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- SERVEROUTPUT [1]
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP FUNCTION dbms_output_test();
    
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    BEGIn
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('t');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 2');
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP FUNCTION dbms_output_test();
    
    -- SERVEROUTPUT [2]
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT ('ORAFCE TEST 1');
    	PERFORM DBMS_OUTPUT.NEW_LINE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP FUNCTION dbms_output_test();
    
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('t');
    	PERFORM DBMS_OUTPUT.PUT ('ORAFCE TEST 2');
    	PERFORM DBMS_OUTPUT.NEW_LINE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP FUNCTION dbms_output_test();
    
    -- SERVEROUTPUT [3]
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.DISABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP FUNCTION dbms_output_test();
    
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('t');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP FUNCTION dbms_output_test();
```

## DBMS_PIPE 
DBMS_PIPE包用于在同一实例的不同会话之间进行通信；注意，如果用户要执行包dbms_pipe中的过程和函数,则必须要为用户授权。DBMS_PIPE包含以下接口：

| 接口             | 描述                                                         |
| ---------------- | ------------------------------------------------------------ |
| *CREATE_PIPE     | 用于建立公用管道或私有管道。如果将参数private设置为TRUE，则建立私有管道；如果设置为FALSE，则建立公用管道。 |
| *PACK_MESSAGE    | 用于将消息写入到本地消息缓冲区，包含类型number，bytea，date，string，timestamp, record |
| *SEND_MESSAGE    | 用于将本地消息缓冲区中的内容发送到管道                       |
| *RECEIVE_MESSAGE | 用于接收管道消息                                             |
|NEXT_ITEM_TYPE	|用于确定本地消息缓冲区下一项的数据类型。如果该函数返回0,则表示管道没有任何消息|
|*UNPACK_MESSAGE	|用于将消息缓冲区的内容写入到变量中|
|*REMOVE_PIPE|	用于删除已经建立的管道|
|PUGER	|用于清除管道中的内容|
|RESET_BUFFER|	用于复位管道缓冲区|
|UNIQUE_SESSION_NAME|	用于为特定会话返回惟一的名称,并且名称的最长度为30字节|

示例：
```
create or replace procedure dbmspipe_crtpipe_pro(in_cno int) as
    declare
    v_no int;
    v_bigint bigint;
    v_bytea bytea;
    v_date date;
    v_int int;
    v_num numeric;
    v_text text;
    v_tmptz timestamp with time zone;
    begin
      select c,c_bigint,c_bytea,c_date,c_int,c_num,c_text,c_tmptz
      from dbmspipe_tbl
      where c=in_cno
      into v_no,v_bigint,v_bytea,v_date,v_int,v_num,v_text,v_tmptz;
      perform dbms_pipe.create_pipe('bigint_pipe1'||v_no);
      perform dbms_pipe.pack_message(v_bigint);
      perform dbms_pipe.send_message('bigint_pipe1'||v_no);
      perform dbms_pipe.create_pipe('bigint_pipe2'||v_no,50);
      perform dbms_pipe.pack_message(v_bigint);
      perform dbms_pipe.send_message('bigint_pipe2'||v_no);
      perform dbms_pipe.create_pipe('bigint_pipe3'||v_no,100,true);
      perform dbms_pipe.pack_message(v_bigint);
      perform dbms_pipe.send_message('bigint_pipe3'||v_no);
      perform dbms_pipe.create_pipe('bigint_pipe4'||v_no,200,false);
      perform dbms_pipe.pack_message(v_bigint);
      perform dbms_pipe.send_message('bigint_pipe4'||v_no);
    
      perform dbms_pipe.create_pipe('bytea_pipe1'||v_no);
      perform dbms_pipe.pack_message(v_bytea);
      perform dbms_pipe.send_message('bytea_pipe1'||v_no);
      perform dbms_pipe.create_pipe('bytea_pipe2'||v_no,50);
      perform dbms_pipe.pack_message(v_bytea);
      perform dbms_pipe.send_message('bytea_pipe2'||v_no);
      perform dbms_pipe.create_pipe('bytea_pipe3'||v_no,100,true);
      perform dbms_pipe.pack_message(v_bytea);
      perform dbms_pipe.send_message('bytea_pipe3'||v_no);
      perform dbms_pipe.create_pipe('bytea_pipe4'||v_no,200,false);
      perform dbms_pipe.pack_message(v_bytea);
      perform dbms_pipe.send_message('bytea_pipe4'||v_no);
    
      perform dbms_pipe.create_pipe('date_pipe1'||v_no);
      perform dbms_pipe.pack_message(v_date);
      perform dbms_pipe.send_message('date_pipe1'||v_no);
      perform dbms_pipe.create_pipe('date_pipe2'||v_no,50);
      perform dbms_pipe.pack_message(v_date);
      perform dbms_pipe.send_message('date_pipe2'||v_no);
      perform dbms_pipe.create_pipe('date_pipe3'||v_no,100,true);
      perform dbms_pipe.pack_message(v_date);
      perform dbms_pipe.send_message('date_pipe3'||v_no);
      perform dbms_pipe.create_pipe('date_pipe4'||v_no,200,false);
      perform dbms_pipe.pack_message(v_date);
      perform dbms_pipe.send_message('date_pipe4'||v_no);
    
      perform dbms_pipe.create_pipe('int_pipe1'||v_no);
      perform dbms_pipe.pack_message(v_int);
      perform dbms_pipe.send_message('int_pipe1'||v_no);
      perform dbms_pipe.create_pipe('int_pipe2'||v_no,50);
      perform dbms_pipe.pack_message(v_int);
      perform dbms_pipe.send_message('int_pipe2'||v_no);
      perform dbms_pipe.create_pipe('int_pipe3'||v_no,100,true);
      perform dbms_pipe.pack_message(v_int);
      perform dbms_pipe.send_message('int_pipe3'||v_no);
      perform dbms_pipe.create_pipe('int_pipe4'||v_no,200,false);
      perform dbms_pipe.pack_message(v_int);
      perform dbms_pipe.send_message('int_pipe4'||v_no);
    
      perform dbms_pipe.create_pipe('num_pipe1'||v_no);
      perform dbms_pipe.pack_message(v_num);
      perform dbms_pipe.send_message('num_pipe1'||v_no);
      perform dbms_pipe.create_pipe('num_pipe2'||v_no,50);
      perform dbms_pipe.pack_message(v_num);
      perform dbms_pipe.send_message('num_pipe2'||v_no);
      perform dbms_pipe.create_pipe('num_pipe3'||v_no,100,true);
      perform dbms_pipe.pack_message(v_num);
      perform dbms_pipe.send_message('num_pipe3'||v_no);
      perform dbms_pipe.create_pipe('num_pipe4'||v_no,200,false);
      perform dbms_pipe.pack_message(v_num);
      perform dbms_pipe.send_message('num_pipe4'||v_no);
    
      perform dbms_pipe.create_pipe('text_pipe1'||v_no);
      perform dbms_pipe.pack_message(v_text);
      perform dbms_pipe.send_message('text_pipe1'||v_no);
      perform dbms_pipe.create_pipe('text_pipe2'||v_no,50);
      perform dbms_pipe.pack_message(v_text);
      perform dbms_pipe.send_message('text_pipe2'||v_no);
      perform dbms_pipe.create_pipe('text_pipe3'||v_no,100,true);
      perform dbms_pipe.pack_message(v_text);
      perform dbms_pipe.send_message('text_pipe3'||v_no);
      perform dbms_pipe.create_pipe('text_pipe4'||v_no,200,false);
      perform dbms_pipe.pack_message(v_text);
      perform dbms_pipe.send_message('text_pipe4'||v_no);
    
      perform dbms_pipe.create_pipe('tmptz_pipe1'||v_no);
      perform dbms_pipe.pack_message(v_tmptz);
      perform dbms_pipe.send_message('tmptz_pipe1'||v_no);
      perform dbms_pipe.create_pipe('tmptz_pipe2'||v_no,50);
      perform dbms_pipe.pack_message(v_tmptz);
      perform dbms_pipe.send_message('tmptz_pipe2'||v_no);
      perform dbms_pipe.create_pipe('tmptz_pipe3'||v_no,100,true);
      perform dbms_pipe.pack_message(v_tmptz);
      perform dbms_pipe.send_message('tmptz_pipe3'||v_no);
      perform dbms_pipe.create_pipe('tmptz_pipe4'||v_no,200,false);
      perform dbms_pipe.pack_message(v_tmptz);
      perform dbms_pipe.send_message('tmptz_pipe4'||v_no);
    end;
    /
    
    --创建接收pipe message，打印message子存储过程
    create or replace procedure rec_subpro(in_pipename varchar) as
    declare
    v_num numeric;
    v_bytea bytea;
    v_date date;
    v_str varchar;
    v_tmptz timestamp with time zone;
    begin
      perform dbms_output.disable();
      perform dbms_output.enable();
      perform dbms_output.serveroutput ('t');
      perform dbms_pipe.receive_message(in_pipename);
      if in_pipename like '%int%' or in_pipename like 'num' then
    v_num := dbms_pipe.unpack_message_number();
    perform dbms_output.put_line(in_pipename || ' message: '||v_num);
      elsif in_pipename like '%bytea%' then
    v_bytea := dbms_pipe.unpack_message_bytea();
    perform dbms_output.put_line(in_pipename || ' message: '||v_bytea);
      elsif in_pipename like '%date%' then
    v_date := dbms_pipe.unpack_message_date();
    perform dbms_output.put_line(in_pipename || ' message: '||v_date::text);
      elsif in_pipename like '%text%' then
    v_str := dbms_pipe.unpack_message_text();
    perform dbms_output.put_line(in_pipename || ' message: '||v_str);
      elsif in_pipename like '%tmptz%' then
    v_tmptz := dbms_pipe.unpack_message_timestamp();
    perform dbms_output.put_line(in_pipename || ' message: '||v_tmptz::text);
      end if;
      perform dbms_pipe.remove_pipe(in_pipename);
    end;
    /
    --unpack_message_*测试：接收pipe中各种数据类型的message（record除外），接收后remove_pipe，打印出message
    create or replace procedure dbmspipe_rec_pro(in_cno int) as
    begin
      call rec_subpro('bigint_pipe1'||in_cno);
      call rec_subpro('bigint_pipe2'||in_cno);
      call rec_subpro('bigint_pipe3'||in_cno);
      call rec_subpro('bigint_pipe4'||in_cno);
    
      call rec_subpro('bytea_pipe1'||in_cno);
      call rec_subpro('bytea_pipe2'||in_cno);
      call rec_subpro('bytea_pipe3'||in_cno);
      call rec_subpro('bytea_pipe4'||in_cno);
    
      call rec_subpro('date_pipe1'||in_cno);
      call rec_subpro('date_pipe2'||in_cno);
      call rec_subpro('date_pipe3'||in_cno);
      call rec_subpro('date_pipe4'||in_cno);
    
      call rec_subpro('int_pipe1'||in_cno);
      call rec_subpro('int_pipe2'||in_cno);
      call rec_subpro('int_pipe3'||in_cno);
      call rec_subpro('int_pipe4'||in_cno);
    
      call rec_subpro('num_pipe1'||in_cno);
      call rec_subpro('num_pipe2'||in_cno);
      call rec_subpro('num_pipe3'||in_cno);
      call rec_subpro('num_pipe4'||in_cno);
    
      call rec_subpro('text_pipe1'||in_cno);
      call rec_subpro('text_pipe2'||in_cno);
      call rec_subpro('text_pipe3'||in_cno);
      call rec_subpro('text_pipe4'||in_cno);
    
      call rec_subpro('tmptz_pipe1'||in_cno);
      call rec_subpro('tmptz_pipe2'||in_cno);
      call rec_subpro('tmptz_pipe3'||in_cno);
      call rec_subpro('tmptz_pipe4'||in_cno);
    end;
    /
    --sessionA:
    call dbmspipe_crtpipe_pro(1);
    --sessionB:
    call dbmspipe_rec_pro(1);
    --sessionA:
    call dbmspipe_crtpipe_pro(2);
    --sessionB:
    call dbmspipe_rec_pro(2);
    --sessionA:
    call dbmspipe_crtpipe_pro(3);
    --sessionB:
    call dbmspipe_rec_pro(3);
    --sessionA:
    call dbmspipe_crtpipe_pro(4);
    --sessionB:
    call dbmspipe_rec_pro(4);
    --sessionA:
    call dbmspipe_crtpipe_pro(5);
    --sessionB:
    call dbmspipe_rec_pro(5);
```
    
## DBMS_UTILITY
DBMS_UTILITY包含一个接口： FORMAT_CALL_STACK，这个内置函数返回一个格式化的字符串，它显示了执行调用堆栈，直至此函数的调用点处的所有过程或者函数的调用顺序。

示例：
```
 create or replace function dbms_uti_func() returns text as
    declare
    v_str1 text;
    v_str2 text;
    v_str3 text;
    v_str4 text;
    begin
      v_str1 := dbms_utility.format_call_stack();
      select regexp_replace(v_str1,'[ 0-9a-fA-F]{4}[0-9a-fA-F]{4}','   0','g') into v_str1;
      select regexp_replace(v_str1,'[45()]','','g') into v_str1;
      v_str2 := dbms_utility.format_call_stack('o');
      select regexp_replace(v_str2,'[ 0-9a-fA-F]{4}[0-9a-fA-F]{4}','   0','g') into v_str2;
      select regexp_replace(v_str2,'[45()]','','g') into v_str2;
      v_str3 := dbms_utility.format_call_stack('p');
      select regexp_replace(v_str3,'[ 0-9a-fA-F]{4}[0-9a-fA-F]{4}','   0','g') into v_str3;
      select regexp_replace(v_str3,'[45()]','','g') into v_str3;
      v_str4 := dbms_utility.format_call_stack('s');
      select regexp_replace(v_str4,'[ 0-9a-fA-F]{4}[0-9a-fA-F]{4}','   0','g') into v_str4;
      select regexp_replace(v_str4,'[45()]','','g') into v_str4;
      return 'v_str1:
    '||v_str1 || '
    v_str2:
    '|| v_str2|| '
    v_str3:
    '|| v_str3|| '
    v_str4:
    '|| v_str4;
    end;
    /
    select dbms_uti_func();
```
   

## UTL_FILE
UTL_FILE包提供文本文件输入和输出功能。
UTL_FILE包含以下接口：

| 接口         | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| *FOPEN       | 用于打开文件                                                 |
| IS_OPEN      | 用于确定文件是否已经被打开                                   |
| FCLOSE       | 用于关闭已经打开的文件                                       |
| FCLOSE_ALL   | 该过程用于关闭当前打开的所有文件                             |
| GET_LINE     | 用于从已经打开的文件中读取行内容，行内容会被读取到输出缓冲区 |
| GET_NEXTLINE | 用于从已经打开的文件中读取下一条行内容                       |
| *PUT         | 用于将缓冲区内容写入到文件中。当使用PUT过程的时候，文件必须以写方式打开，在写入缓冲区之后，如果要结束行，那么可以使用NEW_LINE过程 |
| NEW_LINE     | 该过程用于为文件增加行终止符                                 |
| *PUT_LINE    | 该过程用于将文本缓冲区内容写入到文件中。当使用该过程为文件追加内容时，会自动在文件的尾部追加行终止符。 |
| FFLUSH       | 用于将数据强制性写入到文件中，正常情况下，当给文件写入数据的时候，数据会被暂时的放到缓存中。过程FFLUSH用于强制将数据写入到文件中。 |
| FREMOVE      | 用于删除磁盘文件                                             |
| *FCOPY       | 用于将源文件的全部或者部分内容复制到目标文件中。             |
| *FRENAME     | 该过程用于修改已经存在的文件名字，其作用于UNIX的MV命令完全相同，在修改文件名字的时候，通过指定overwrite参数可以覆盖已经存在的文件 |
| FGETATTR     | 读取磁盘上的文件并返回文件的属性                             |
| FRENAME      | 将一个存在的文件重命名                                       |
| PUTF         | 写入格式化的内容到文件中                                     |

示例：
```
 create or replace procedure utlfile_open_prowa() as
    declare
    v_count int;
    v_fileint integer;
    begin
      --open_node=w
      v_fileint := utl_file.fopen('/data1/tbasev5_autotest/tbaseTest/TbaseV5/pro_package/data/utl_file_dir','file_w.txt','w');
      perform utl_file.put_line(v_fileint,'write file test.');
      if utl_file.is_open(v_fileint) then
    perform utl_file.fclose(v_fileint);
      end if;
      v_fileint := utl_file.fopen('/data1/tbasev5_autotest/tbaseTest/TbaseV5/pro_package/data/utl_file_dir','file_w.txt','w',50);
      perform utl_file.new_line(v_fileint);
      perform utl_file.put_line(v_fileint,'一二三四五六七八九十');
      if utl_file.is_open(v_fileint) then
    perform utl_file.fclose(v_fileint);
      end if;
      v_fileint := utl_file.fopen('/data1/tbasev5_autotest/tbaseTest/TbaseV5/pro_package/data/utl_file_dir','file_w.txt','w',18,'SQL_ASCII');
      perform utl_file.new_line(v_fileint);
      perform utl_file.put_line(v_fileint,'nice to meet you');
      if utl_file.is_open(v_fileint) then
    perform utl_file.fclose(v_fileint);
      end if;
      v_fileint := utl_file.fopen('/data1/tbasev5_autotest/tbaseTest/TbaseV5/pro_package/data/utl_file_dir','file_w.txt','w',31,'UTF-8');
      perform utl_file.new_line(v_fileint);
      perform utl_file.put_line(v_fileint,'abcdefg hijklmn opq rst uvw xyz');
      if utl_file.is_open(v_fileint) then
    perform utl_file.fclose(v_fileint);
      end if;
      v_fileint := utl_file.fopen('/data1/tbasev5_autotest/tbaseTest/TbaseV5/pro_package/data/utl_file_dir','file_w.txt','w',88,'GBK');
      perform utl_file.new_line(v_fileint);
      perform utl_file.put_line(v_fileint,'hello');
      if utl_file.is_open(v_fileint) then
    perform utl_file.fclose(v_fileint);
      end if;
      --open_mode=a
      v_fileint := utl_file.fopen('/data1/tbasev5_autotest/tbaseTest/TbaseV5/pro_package/data/utl_file_dir','file_w.txt','a');
      perform utl_file.put_line(v_fileint,'write file test.');
      if utl_file.is_open(v_fileint) then
    perform utl_file.fclose(v_fileint);
      end if;
      v_fileint := utl_file.fopen('/data1/tbasev5_autotest/tbaseTest/TbaseV5/pro_package/data/utl_file_dir','file_w.txt','a',50);
      perform utl_file.new_line(v_fileint);
      perform utl_file.put_line(v_fileint,'一二三四五六七八九十');
      if utl_file.is_open(v_fileint) then
    perform utl_file.fclose(v_fileint);
      end if;
      v_fileint := utl_file.fopen('/data1/tbasev5_autotest/tbaseTest/TbaseV5/pro_package/data/utl_file_dir','file_w.txt','a',18,'SQL_ASCII');
      perform utl_file.new_line(v_fileint);
      perform utl_file.put_line(v_fileint,'nice to meet you');
      if utl_file.is_open(v_fileint) then
    perform utl_file.fclose(v_fileint);
      end if;
      v_fileint := utl_file.fopen('/data1/tbasev5_autotest/tbaseTest/TbaseV5/pro_package/data/utl_file_dir','file_w.txt','a',31,'UTF-8');
      perform utl_file.new_line(v_fileint);
      perform utl_file.put_line(v_fileint,'abcdefg hijklmn opq rst uvw xyz');
      if utl_file.is_open(v_fileint) then
    perform utl_file.fclose(v_fileint);
      end if;
      v_fileint := utl_file.fopen('/data1/tbasev5_autotest/tbaseTest/TbaseV5/pro_package/data/utl_file_dir','file_w.txt','a',88,'GBK');
      perform utl_file.new_line(v_fileint);
      perform utl_file.put_line(v_fileint,'hello');
      if utl_file.is_open(v_fileint) then
    perform utl_file.fclose(v_fileint);
      end if;
    exception
      when others then
    raise notice 'EXP: something wrong.';
    end;
    /
    call utlfile_open_prowa();
```
   
